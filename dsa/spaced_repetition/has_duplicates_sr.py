"""
Has Duplicates - Spaced Repetition

Write a function, has_duplicates, that takes in a list as an argument.
The function should return a boolean indicating whether or not the list
contains any duplicate elements.

Example:
has_duplicates([1, 2, 3, 4]) â†’ False
has_duplicates([1, 2, 2, 3]) â†’ True
has_duplicates([]) â†’ False
has_duplicates(['a', 'b', 'c', 'a']) â†’ True

Write your own test cases and implement the solution.
After completing, analyze time and space complexity.
"""


def has_duplicates(lst: list[int | str | tuple | bool]) -> bool:
    """
    Checks if the input list contains any duplicate elements.

    Args:
        lst (list[int | str | tuple | bool]): The list to check for duplicates. Elements can be integers, strings, tuples, or booleans.

    Returns:
        bool: True if there are duplicate elements in the list, False otherwise.
    """
    unique_values = set()
    for element in lst:
        if element in unique_values:
            return True
        else:
            unique_values.add(element)
    return False


def generate_large_list(
    lst_len: int, repeat_value: int | str | tuple | bool
) -> list[int | str | tuple | bool]:
    """
    Generates a list of specified length, filled with a repeated value.

    Args:
        lst_len (int): The length of the list to generate.
        repeat_value (int | str | tuple | bool): The value to repeat in the list.

    Returns:
        list[int | str | tuple | bool]: A list containing the repeated value.

    Example:
        >>> generate_large_list(3, 'a')
        ['a', 'a', 'a']
    """
    return [repeat_value] * lst_len


def test_has_duplicates():
    """
    Tests the has_duplicates function with various input lists to verify its correctness.

    The test cases cover:
    - Lists with no duplicates (integers, tuples)
    - Lists with duplicates (integers, strings, tuples, booleans)
    - Empty lists
    - Lists with different data types
    - Large lists generated by generate_large_list

    Asserts that the output of has_duplicates matches the expected result for each test case.
    """

    # Test 1
    lst = [1, 2, 3, 4]
    expected = False
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 2
    lst = [1, 2, 2, 3]
    expected = True
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 3
    lst = []
    expected = False
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 4
    lst = ["a", "b", "c", "a"]
    expected = True
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 5
    lst = [(1, 2), (3, 4), (1, 2)]
    expected = True
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 6
    lst = [(1, 2), (3, 4), (2, 1)]
    expected = False
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 7
    lst = [True, False, True]
    expected = True
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"

    # Test 8
    lst = generate_large_list(10000, 256)
    expected = True
    result = has_duplicates(lst)
    assert expected == result, f"TEST FAILED, Expected: {expected}, got {result}"


# Run your tests
test_has_duplicates()

"""
=== EXERCISE #5 SUMMARY - HAS DUPLICATES (SPACED REPETITION) ===

Pattern Mastery: ðŸŸ¢ STRONG UNDERSTANDING
- Optimal set-based approach with early termination
- Clear understanding of "have I seen this before?" pattern
- Proper use of set data structure for O(1) lookups

Interview Readiness: ðŸŸ¢ PROFESSIONAL APPROACH
- Asked clarifying questions about data types (good interview behavior)
- Comprehensive type hints showing attention to detail
- Large input testing for correctness verification
- Accurate complexity analysis with best/worst case distinctions

Spaced Repetition Performance: ðŸ“ˆ ACCELERATING SPEED
- Quick completion time showing pattern familiarity
- Comprehensive edge case coverage across multiple data types
- Self-driven stress testing with large inputs
- Helper function creation for test data generation

Next Review Schedule:
- Tomorrow (Aug 30): 1st review
- Sept 1: 2nd review (+2 days)
- Sept 4: 3rd review (+3 days)
- Sept 8: 4th review (+4 days)
- Interview Sept 10: Should be automatic by then

Time Complexity: O(1) best case, O(n) worst case
Space Complexity: O(1) best case, O(n) worst case  
Pattern Type: Set-based existence checking with early termination
Core Skills: Hash table optimization, early return patterns

Key Strengths Demonstrated:
- Professional requirements clarification about data types
- Understanding of early termination optimization benefits
- Comprehensive test coverage including edge cases and stress tests
- Accurate complexity analysis distinguishing best/worst cases
- Clean implementation with proper boolean logic flow

Status: ðŸ”„ NEEDS SPACED REPETITION - Follow review schedule to achieve mastery
Note: Shows solid grasp of optimization principles and testing strategies
"""
